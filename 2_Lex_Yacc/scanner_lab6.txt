%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SYMBOLS 100

typedef struct {
    char symbol[50];
    int code;
} SymbolTableEntry;

typedef struct {
    char token[50];
    int position;
} PIFEntry;

SymbolTableEntry symbolTable[MAX_SYMBOLS];
int symbolCount = 0;

PIFEntry pif[MAX_SYMBOLS];
int pifCount = 0;

int addSymbol(const char *symbol) {
    for (int i = 0; i < symbolCount; i++) {
        if (strcmp(symbolTable[i].symbol, symbol) == 0) {
            return i;
        }
    }
    strcpy(symbolTable[symbolCount].symbol, symbol);
    symbolTable[symbolCount].code = symbolCount;
    return symbolCount++;
}

void addPIF(const char *token, int position) {
    strcpy(pif[pifCount].token, token);
    pif[pifCount].position = position;
    pifCount++;
}

void printSymbolTable() {
    printf("Symbol Table:\n");
    for (int i = 0; i < symbolCount; i++) {
        printf("%d: %s\n", symbolTable[i].code, symbolTable[i].symbol);
    }
}

void printPIF() {
    printf("Program Internal Form:\n");
    for (int i = 0; i < pifCount; i++) {
        printf("%s: %d\n", pif[i].token, pif[i].position);
    }
}

int yywrap() {
    return 1;
}
%}

DIGIT       [0-9]
LETTER      [a-zA-Z]
IDENTIFIER  {LETTER}({LETTER}|{DIGIT}|_)*
INTEGER     [+-]?[1-9]{DIGIT}*
FLOAT       {INTEGER}"."{DIGIT}+
STRING      \'[a-zA-Z0-9 !?.-]*\'
COMMENT     \/\/[^\n]*

RESERVED    clatite|cu|nutella|define|num|decimal|string|structure|begin|end|check|then|otherwise|loop|perform|read|write
OPERATOR    \+|\-|\*|\/|:=|<|<=|=|>=|>|<>
SEPARATOR   \[|\]|\{|\}|:|\(|\)|;|,|\.|'

%%

"clatite" | "cu" | "nutella" { addPIF(yytext, 0); }
"define"  { addPIF(yytext, 0); }
"num"     { addPIF(yytext, 0); }
"decimal" { addPIF(yytext, 0); }
"string"  { addPIF(yytext, 0); }
"structure" { addPIF(yytext, 0); }
"begin"   { addPIF(yytext, 0); }
"end"     { addPIF(yytext, 0); }
"check"   { addPIF(yytext, 0); }
"then"    { addPIF(yytext, 0); }
"otherwise" { addPIF(yytext, 0); }
"loop"    { addPIF(yytext, 0); }
"perform" { addPIF(yytext, 0); }
"read"    { addPIF(yytext, 0); }
"write"   { addPIF(yytext, 0); }
{IDENTIFIER} { int pos = addSymbol(yytext); addPIF(yytext, pos); }
{INTEGER}    { int pos = addSymbol(yytext); addPIF(yytext, pos); }
{FLOAT}      { int pos = addSymbol(yytext); addPIF(yytext, pos); }
{STRING}     { int pos = addSymbol(yytext); addPIF(yytext, pos); }
{OPERATOR}   { addPIF(yytext, 0); }
{SEPARATOR}  { addPIF(yytext, 0); }
{COMMENT}    { /* ignore comments */ }
\n           { yylineno++; /* increment line number */ }
[ \t\r]+     { /* ignore whitespace */ }
.            { printf("Lexical error at line %d: %s\n", yylineno, yytext); }

%%

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <inputfile>\n", argv[0]);
        exit(1);
    }

    FILE *file = fopen(argv[1], "r");
    if (!file) {
        fprintf(stderr, "Error: could not open file %s\n", argv[1]);
        exit(1);
    }

    yyin = file;
    yylex();
    fclose(file);

    printSymbolTable();
    printPIF();

    return 0;
}
